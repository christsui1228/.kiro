---
inclusion: always
---

# Spec 开发规范

## 语言规范
- 所有文档必须使用简体中文
- 代码注释使用简体中文
- 变量名和函数名使用英文，但注释说明用简体中文

## 命令行运行规范
- 所有 Python 相关命令必须使用 `pdm run` 前缀
- 示例：`pdm run python script.py`、`pdm run pytest`、`pdm run black .`

## Spec 文件结构规范
- 需求文档：`requirements.md` - 使用 EARS 格式的验收标准
- 设计文档：`design.md` - 包含架构图、组件设计、数据模型
- 任务文档：`tasks.md` - 可执行的编码任务，引用具体需求

## 任务编写规范
- 每个任务必须是具体的编码活动
- 任务描述要明确，包含要修改的文件
- 可选任务用 `*` 标记（主要是测试相关）
- 每个任务必须引用对应的需求编号

## 目录命名规范
- 文件名保持英文，便于系统兼容性

## 开发流程规范

### 核心原则
在进行任何代码修改之前，必须遵循以下开发流程：

#### 1. 需求分析阶段
- 必须先完整理解用户需求
- 明确功能范围和边界条件
- 识别潜在的技术风险和依赖关系

#### 2. 方案设计阶段
- 提供多个技术方案选项
- 详细说明每个方案的优缺点
- 包含性能、可维护性、扩展性的考量
- **重要：未经用户明确同意，不得开始编写代码**

#### 3. 实施前确认
- 向用户展示完整的实施计划
- 说明将要修改的文件和主要变更点
- 获得用户明确的"开始实施"确认后才能进行代码修改

#### 4. 渐进式实施
- 采用小步骤、可回滚的方式进行修改
- 每个重要节点都要向用户汇报进度
- 遇到问题时立即停止并寻求用户指导

### 禁止行为
- 不得在方案讨论阶段直接开始编码
- 不得在未获得明确同意的情况下修改现有代码
- 不得跳过设计阶段直接进入实施
- 不得在用户提出问题时立即给出代码示例（除非明确要求）
- **不得擅自创建或修改 .md 文档，必须获得用户明确指令**

### 沟通要求
- 使用简体中文进行所有交流
- 保持专业但友好的语调
- 优先提供思路和方案，而非直接的代码实现
- 在每个阶段都要征求用户的意见和确认

### 方案设计原则
- **根治性方案**: 不提供头痛医头脚痛医脚的临时解决方案
- **现代化优先**: 优先采用最新的技术和最佳实践
- **系统性思考**: 从架构层面解决问题，而非局部修补
- **可扩展性**: 方案必须考虑未来的扩展和维护需求
- **技术前瞻性**: 选择有长期发展前景的技术方案

### 异常处理
如果用户明确要求跳过某些流程步骤，需要：
1. 确认用户完全理解跳过的风险
2. 记录用户的明确授权
3. 在实施过程中保持额外的谨慎

### 方案质量标准
- **避免临时方案**: 不提供仅解决表面问题的方案
- **追求根本解决**: 深入分析问题根源，提供系统性解决方案
- **现代化技术**: 优先使用最新稳定版本和现代化架构模式
- **最佳实践**: 遵循行业最佳实践和设计模式
- **长远考虑**: 方案要能适应未来 2-3 年的技术发展趋势

#### 示例对比
❌ **临时方案**: "可以用 try-catch 包装一下这个错误"
✅ **根治方案**: "建议重构错误处理架构，使用统一的异常处理中间件和结构化错误响应"

❌ **过时方案**: "可以用 requests 库同步调用"
✅ **现代方案**: "使用 aiohttp 异步客户端，配合 TaskIQ 任务队列处理"

## 任务管理规范

### 混合管理策略
采用 Spec 任务和模块任务的混合管理方式：

#### Spec 任务管理
- **位置**: `.kiro/specs/{功能名}/tasks.md`
- **适用场景**: 
  - 需要完整需求分析和设计的新功能
  - 复杂的功能开发项目
  - 需要跨模块协作的任务
- **流程**: requirements → design → tasks → 实施
- **示例**: PSD图层预览功能、用户认证系统

#### 模块任务管理  
- **位置**: `features/{模块名}/task-management.md`
- **适用场景**:
  - 模块内部的技术债务和优化
  - 不需要完整 spec 流程的小任务
  - 模块维护和重构任务
- **格式**: 使用 ID-XXX 编号系统
- **示例**: 性能优化、算法改进、依赖升级

#### 任务状态同步
- Spec 任务完成后，同步更新模块 task-management.md 状态
- 模块任务如需升级为 Spec，创建对应的 spec 目录并更新引用
- 保持两个系统的任务状态一致性

## TaskIQ + NATS 架构规范

### 核心架构原则
- **发布-订阅模式**: 使用 NATS 进行事件驱动的异步通信
- **TaskIQ 任务**: 所有异步处理使用 TaskIQ 任务装饰器 `@broker.task`
- **事件监听**: 使用 `@subscribe_event` 装饰器监听 NATS 事件
- **模块化设计**: 每个服务模块有独立的 `tasks.py` 文件

### 文件结构规范
```
features/{模块名}/services/{子服务}/
├── tasks.py          # TaskIQ 任务定义和事件监听器
├── {service}.py      # 核心业务逻辑
└── README.md         # 服务文档
```

### TaskIQ 任务规范
```python
# 任务定义
@broker.task
async def async_process_something(param1: str, param2: int) -> dict:
    """异步处理任务
    
    Args:
        param1: 参数说明
        param2: 参数说明
        
    Returns:
        dict: 处理结果
    """
    try:
        # 发布开始事件
        await publish_event(PROCESS_STARTED, {...})
        
        # 执行业务逻辑
        result = await do_something(param1, param2)
        
        # 发布完成事件
        await publish_event(PROCESS_COMPLETED, {...})
        
        return result
        
    except Exception as e:
        # 发布失败事件
        await publish_event(PROCESS_FAILED, {...})
        raise
```

### NATS 事件监听规范
```python
# 事件监听器
@subscribe_event(PROCESS_COMPLETED, model=ProcessCompletedEvent)
async def on_process_completed(evt: ProcessCompletedEvent) -> None:
    """监听处理完成事件
    
    Args:
        evt: 事件数据模型
    """
    try:
        # 更新数据库状态
        async with get_session_context() as db:
            await update_task_status(db, evt.task_id, "completed")
            await db.commit()
            
    except Exception as e:
        logger.error(f"事件处理失败: {e}")
```

### 事件定义规范
- **事件主题**: 在 `events/subjects.py` 中定义常量
- **事件模型**: 在 `events/schemas.py` 中定义 Pydantic 模型
- **事件发布**: 使用 `events/publisher.py` 的 `publish_event` 函数
- **事件订阅**: 使用 `events/subscriber.py` 的 `@subscribe_event` 装饰器

### 数据存储策略
- **临时数据**: 使用 NATS 消息队列，支持 TTL 自动过期
- **持久数据**: 使用数据库存储，通过事件监听器更新状态
- **缓存数据**: 可选使用 Redis，但优先使用 NATS 的内存存储
- **文件存储**: 本地临时文件 + OSS/R2 永久存储

### 错误处理规范
- **重试机制**: 在 TaskIQ 任务中实现，使用指数退避
- **降级策略**: NATS 不可用时降级到数据库查询
- **事件补偿**: 失败事件包含足够信息用于问题排查
- **监控告警**: 关键事件失败时发送告警

### 禁止使用的模式
- ❌ 不要使用 Redis 作为主要的消息队列
- ❌ 不要在 NATS 事件中存储大量数据（>1MB）
- ❌ 不要跳过事件发布直接调用其他模块的函数
- ❌ 不要在事件监听器中执行长时间运行的任务